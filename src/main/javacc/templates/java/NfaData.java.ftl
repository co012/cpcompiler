[#ftl strict_vars=true]
[#--
/* Copyright (c) 2021 Jonathan Revusky, revusky@javacc.com
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *     * Redistributions of source code must retain the above copyright notices,
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name Jonathan Revusky nor the names of any contributors 
 *       may be used to endorse or promote products derived from this software 
 *       without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
 --]

 [#--
    This template handles the generation of a class that is a holder
    for all the static data that represents an NFA state machine
 --]
 /* Generated by: ${generated_by}. ${filename} */

[#var NFA_RANGE_THRESHOLD = 16]
[#var multipleLexicalStates = grammar.lexerData.lexicalStates.size()>1]
[#var TT = "TokenType."]
 
[#if grammar.parserPackage?has_content]
    package ${grammar.parserPackage};
    import static ${grammar.parserPackage}.${grammar.constantsClassName}.TokenType.*;
    [#set TT=""]
[/#if]
import java.util.Arrays;
import java.util.BitSet;
import java.util.EnumSet;
[#if multipleLexicalStates]
  import java.util.EnumMap;
[/#if]

/**
 * Holder class for the data used by ${grammar.lexerClassName}
 * to do the NFA thang
 */
class ${grammar.nfaDataClassName} implements ${grammar.constantsClassName} {

  // The functional interface that represents 
  // the acceptance method of an NFA state
  static interface NfaFunction {
    TokenType apply(int ch, BitSet bs, EnumSet<TokenType> validTypes);
  }

 [#if multipleLexicalStates]
  // A lookup of the NFA function tables for the respective lexical states.
  private static final EnumMap<LexicalState,NfaFunction[]> functionTableMap = new EnumMap<>(LexicalState.class);
 [#else]
  [#-- We don't need the above lookup if there is only one lexical state.--]
   static private NfaFunction[] nfaFunctions;
 [/#if]


  // This data holder class is never instantiated
  private ${grammar.nfaDataClassName}() {}

  /**
   * @param the lexical state
   * @return the table of function pointers that implement the lexical state
   */
  static final NfaFunction[] getFunctionTableMap(LexicalState lexicalState) {
    [#if multipleLexicalStates]
      return functionTableMap.get(lexicalState);
    [#else]
     // We only have one lexical state in this case, so we return that!
      return nfaFunctions;
    [/#if]
  }
 
  // Initialize the various NFA method tables
  static {
    [#list grammar.lexerData.lexicalStates as lexicalState]
      NFA_FUNCTIONS_${lexicalState.name}_init();
    [/#list]
  }

  // Just use the canned binary search to check whether the char
  // is in one of the intervals
  private static final boolean checkIntervals(int[] ranges, int ch) {
    int temp;
    return (temp = Arrays.binarySearch(ranges, ch)) >=0 || temp%2 == 0;
  }

 [#list grammar.lexerData.lexicalStates as lexicalState]
   [@GenerateStateCode lexicalState/]
 [/#list]  
}

[#--
  Generate all the NFA transition code
  for the given lexical state
--]
[#macro GenerateStateCode lexicalState]
  [#list lexicalState.allNfaStates as nfaState]
    [#if nfaState.moveRanges.size() >= NFA_RANGE_THRESHOLD]
      [@GenerateMoveArray nfaState/]
    [/#if]
    [#if nfaState.composite]
       [@GenerateCompositeNfaMethod nfaState/]
    [#else]
       [@GenerateSimpleNfaMethod nfaState /]
    [/#if]
  [/#list]

  static private void NFA_FUNCTIONS_${lexicalState.name}_init() {
    NfaFunction[] functions = new NfaFunction[${lexicalState.allNfaStates.size()}];
    [#list lexicalState.allNfaStates as state]
      functions[${state.index}] = ${grammar.nfaDataClassName}::${state.methodName};
    [/#list]
    [#if multipleLexicalStates]
      functionTableMap.put(LexicalState.${lexicalState.name}, functions);
    [#else]
      nfaFunctions = functions;
    [/#if]
  }
[/#macro]

[#--
   Generate the array representing the characters
   that this NfaState "accepts".
   This corresponds to the moveRanges field in 
   com.javacc.core.NfaState
--]
[#macro GenerateMoveArray nfaState]
  [#var moveRanges = nfaState.moveRanges]
  [#var arrayName = nfaState.movesArrayName]
    static private int[] ${arrayName} = ${arrayName}_init();

    static private int[] ${arrayName}_init() {
        int[] result = new int[${nfaState.moveRanges.size()}];
        [#list nfaState.moveRanges as char]
          result[${char_index}] = ${grammar.utils.displayChar(char)};
        [/#list]
        return result;
    }
[/#macro] 

[#--
   Generate the method that represents the transitions
   that correspond to an instanceof com.javacc.core.CompositeNfaState
--]
[#macro GenerateCompositeNfaMethod nfaState]  
    static TokenType ${nfaState.methodName}(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
      TokenType type = null;
    [#var states = nfaState.orderedStates, lastBlockStartIndex=0]
    [#list states as state]
      [#if state_index ==0 || !state.moveRanges.equals(states[state_index-1].moveRanges)]
          [#-- In this case we need a new if or possibly else if --]
         [#if state_index == 0 || state.overlaps(states.subList(lastBlockStartIndex, state_index))]
           [#-- If there is overlap between this state and any of the states
                 handled since the last lone if, we start a new if-else 
                 If not, we continue in the same if-else block as before. --]
           [#set lastBlockStartIndex = state_index]
               if
         [#else]
               else if
         [/#if]    
           ([@NfaStateCondition state /]) {
      [/#if]
      [#if state.nextStateIndex >= 0]
         nextStates.set(${state.nextStateIndex});
      [/#if]
      [#if !state_has_next || !state.moveRanges.equals(states[state_index+1].moveRanges)]
        [#-- We've reached the end of the block. --]
          [#var type = state.nextStateType]
          [#if type??]
            if (validTypes.contains(${TT}${type.label}))
              type = ${TT}${type.label};
          [/#if]
        }
      [/#if]
    [/#list]
      return type;
    }
[/#macro]

[#-- 
  Generate the code for a simple (non-composite) NFA state
--]
[#macro GenerateSimpleNfaMethod nfaState]
  static TokenType ${nfaState.methodName}(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
    [#var type = nfaState.nextStateType]
      if ([@NfaStateCondition nfaState /]) {
        [#if nfaState.nextStateIndex >= 0]
          nextStates.set(${nfaState.nextStateIndex});
        [/#if]
      [#if type??]
        if (validTypes.contains(${TT}${type.label}))
           return ${TT}${type.label};
      [/#if]
    }
    return null;
  }
[/#macro]

[#--
Generate the condition part of the NFA state transition
If the size of the moveRanges vector is greater than NFA_RANGE_THRESHOLD
it uses the canned binary search routine. For the smaller moveRanges
it just generates the inline conditional expression
--]
[#macro NfaStateCondition nfaState]
    [#if nfaState.moveRanges?size < NFA_RANGE_THRESHOLD]
      [@RangesCondition nfaState.moveRanges /]
    [#elseif nfaState.hasAsciiMoves && nfaState.hasNonAsciiMoves]
      ([@RangesCondition nfaState.asciiMoveRanges/])
      || (ch >=128 && checkIntervals(${nfaState.movesArrayName}, ch))
    [#else]
      checkIntervals(${nfaState.movesArrayName}, ch)
    [/#if]
[/#macro]

[#-- 
This is a recursive macro that generates the code corresponding
to the accepting condition for an NFA state. It is used
if NFA state's moveRanges array is smaller than NFA_RANGE_THRESHOLD
(which is set to 16 for now)
--]
[#macro RangesCondition moveRanges]
    [#var left = moveRanges[0], right = moveRanges[1]]
    [#var displayLeft = grammar.utils.displayChar(left), displayRight = grammar.utils.displayChar(right)]
    [#var singleChar = left == right]
    [#if moveRanges?size==2]
       [#if singleChar]
          ch == ${displayLeft}
       [#elseif left +1 == right]
          ch == ${displayLeft} || ch == ${displayRight}
       [#else]
          ch >= ${displayLeft} 
          [#if right < 1114111]
             && ch <= ${displayRight}
          [/#if]
       [/#if]
    [#else]
       ([@RangesCondition moveRanges[0..1]/])||([@RangesCondition moveRanges[2..moveRanges?size-1]/])
    [/#if]
[/#macro]
